title: 异构数据库连接——SQL Server（三、关于OPENQUERY）
author: sunzn
tags:
  - 技能
categories:
  - 数据库
date: 2019-11-04 21:09:00
---
在链接服务器的查询过程中，OPENQUERY的查询效率往往是高于...的查询方式的，目前我有总结两点原因：
* 1.OPENQUERY是将SQL语句以字符串的形式发送到目标数据库服务器上进行查询，返回的是已经处理好的结果集，与在目标服务器上直接查询相比，只是多了服务器之间两次握手交互的时间；
* 2.而...的查询方式是将目标表全部捞到本地数据库的服务器上再进行处理，往往会出现索引丢失、规则冲突这样的情况，特别是在JOIN多张表的时候，每张表都要先丢到本地，然后再统一做处理；加入WHERE条件也是一样的情况，相当于将整张表拿到本地来再进行筛选，全标扫描，并没有使用到索引；

所以在实际使用过程中还是推荐使用OPENQUERY的查询方式。

## 参数传递
关于OPENQUERY的基本用法在上一章已经有讲到，但是对于很多使用者来说，很多场景下都是在使用动态SQL去捞数据，这就涉及到传参，虽然OPENQUERY并不支持参数传递，但是我们可以另辟蹊径，通过拼接动态SQL的方式实现传递查询参数。

这里先给出一个小的DEMO，另外大家可以参考一下这篇博文:http://www.cnblogs.com/Dannier/archive/2011/09/21/openquery.html
>DECLARE @A NVARCHAR(50)
DECLARE @SQL NVARCHAR(500)
SET @A = '001'
SET @SQL = 'SELECT * FROM OPENQUERY(TEST,''SELECT * FROM TEABLE1 WHERE A='''''+@A+''''''')'
EXEC(@SQL)

可以看到里面有很多引号，因为我们需要使用EXEC去执行字符串内的内容，把上述语句变成字符串语句。所以对于字符串语句@SQL来说实际上是有两层的转义嵌套，从而参数@A就套上了五层''。

所以只要按照以上方法传递参数，我们就可以很容易的在我们的存储过程、表值函数里去处理异构数据库的数据了。

## 字符串拼接后执行

经常使用数据库的人都知道，NVARCHAR动态字符串的上限长度是8000，在我们进行传参查询的过程中，有可能会出现SQL语句长度超过8000的情况，遇到这种情况我们应该如何处理？

其实很简单，我们可以将原有的@sql拆分为两个字符串，在执行时进行拼接，如下图所示：

![upload successful](/2020/10/11/异构数据库连接——SQL-Server（三、关于OPENQUERY/pasted-0.png)
这样执行后，我们执行语句字符长度其实已经超过了8000。